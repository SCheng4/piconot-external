Evaluation
Author: Emily Blatter, Nick Carter, Sisi Cheng

================================================================================
================================================================================

TODO On a scale of 1-10, we had to change our ideal syntax by ___. TODO

== 10/4 ==

We started by creating our project and setting up repos. We talked
about what we wanted to do and decided to implement our own syntax.
We took a look at our previous grammars and made a few edits to 
create our new grammar ideal. In particular, we kept the `Proof.`
and `QED.` declarations from our grammar actual, but
we went back to using `=` as our assignment symbol instead of
`=>`. Also, we dropped quotation marks and parentheses where
possible to make our syntax more like plain English.

We had some difficulty figuring out how to structure our intermediate 
representation. Though on the surface, our mathbot looks very similar to the
language implemented in external-lab, there are a few differences that make
it much more difficult to implement. For example, the operators on the lhs 
function differently than the operators on the rhs, so we needed to have
a way to show this difference in the ir. Also, each operator is only really
concerned with the thing to the right of it, so that makes our AST more
stick-like. 

== 10/6 ==

We’ve been making some minor tweaks to the language during the 
class work time while constructing our parser. We’re representing 
it less as a two stick tree and adding more branching, so each 
operator has a direction and a rest, which is the rest of that 
side of the rule, which we recurse onto. We also made it so rest 
is now an Option, which allows us to have a base case when 
parsing a rule for when you get to just an operator and a 
direction with no rest.

In our work session after class, we learned that we could pass a 
list of Surroundings instead of a long series of of things 
that take in a direction and a rest recursively. 
This flattens our parse tree considerably and makes things much neater.

We also literally changed a lot of the types of things. We had been
using a structure that  created a tree of types, but we realized 
that some things really aren't the things they were extending. 
As a result, we have switched
to using a base `AST` that we have everything extend instead.
Now we have a rule that seems to parse properly.

Next, we are starting to add the wrapping around our rules that
express our list of rules and looks like a proof. We are realizing
that we will be able to throw out a lot of the tokens in our parse
as the important parts of the program our unambiguously ordered. 
However, we like the extra keyword tokens, so we are going to keep
them in.

We have decided that our base program will be
`Proof. Recall. QED`.